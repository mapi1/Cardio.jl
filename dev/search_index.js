var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Cardio","category":"page"},{"location":"#Cardio","page":"Home","title":"Cardio","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Cardio]","category":"page"},{"location":"#Cardio.adaptive_hrv_filter-Tuple{Vector{var\"#s5\"} where var\"#s5\"<:Real}","page":"Home","title":"Cardio.adaptive_hrv_filter","text":"adaptivehrvfilter(signal::Vector{<:Real}; removeoutliers::Bool = true, replacenonnormal::Bool = true, adaptivecontrollingcoef::Real = 0.05, proportionalitylimit::Real = 10/100, outlierminzfactor::Real = 3, maxexcesshrv::Real = 20, physiologicalvalues::Tuple{Real, Real} = (200, 2000))\n\nAn addaptive filter for HRV data      Based on: Wessel, N., Voss, A., Malberg, H., Ziehmann, Ch.,          Voss, H. U., Schirdewan, A., Meyerfeldt, U.,Kurths, J.:          Nonlinear analysis of complex phenomena in cardiological data,          Herzschr. Elektrophys., 11(3), 2000, 159-173, doi:10.1007/s003990070035.\n\nFilters out unphysiological beats in the RR series with the ability to replace them.\n\nArgs:\n\n'signal::Vector': HRV in ms\n\nKeyword Args\n\n'remove_outliers::Bool = true': option if non physiological outliers shall be removed\n'replace_nonnormal::Bool = true': if true, non normal HRV values are replaced\n'adaptivecontrollingcoef::Real = 0.05': ???\n'proportionality_limit::Real = 10/100': ???\n'outlierminzfactor::Real = 3': ???\n'maxexcesshrv::Real = 20': ???\n'physiological_values::Tuple{Real, Real} = (200, 2000)': Definition of the physiological values, scheme: (min, max)\n\nReturn\n\nReturn value depends on keyword args\n\njulia> adaptive_hrv_filter(signal)\n\n\n\n\n\n","category":"method"},{"location":"#Cardio.detectRPeaks-Tuple{Vector{var\"#s8\"} where var\"#s8\"<:Real, Real}","page":"Home","title":"Cardio.detectRPeaks","text":"detectRPeaks(ecg::Vector{<:Real}, samplerate::Real; minPeakDist::Real = 0.360)\n\nTODO check minDist Find R peaks in ECG signals as specified by Benitez et al. See http://dx.doi.org/10.1016/S0010-4825(01)00009-9 for more information\n\nArgs:\n\n'ecg::Vector{<:Real}': ECG data\n'samplerate::Real': Sampling rate [Hz]\n'minPeakDist::Real': minimum distance between consecutive peaks [s]\n\nReturn:\n\n'res::Vector{Int64}': Vector containing the position of the R peaks in ecg, divide by samplerate to get values in a time base\n\nExamples\n\njulia> a = detectRPeaks(ecg, fs)\nVector{Int64} with ....\n\n\n\n\n\n","category":"method"},{"location":"#Cardio.detrend-Tuple{Vector{var\"#s9\"} where var\"#s9\"<:Real}","page":"Home","title":"Cardio.detrend","text":"detrend(signal::Vector{<:Real}; p::Int = 1, coefs::Union{Vector{<:Real}, Nothing, Real} = nothing, return_coefs::Bool = false)\n\nDetrend a signal by removing polynomial trend of order p using build in least squares. Choose p = 0 to remove only mean or input coefficents from previous detrending to detrend by those.\n\nArgs:\n\nsignal::Vector: Data Vector containing te signal\np::Int: order of polynomial\ncoefs::Union{Vector{<:Real}, Nothing, Real}: Coefficents to do the same detrending on different signal\nreturn_coefs::Bool: if true returns coeficients detrendet by\n\nReturn:\n\nnewSignal: The detrended sigal\nOr if return_coefs = true:\n(newSignal, coefs): The detrended sigal and the estimated coefficents from order 0 to  p\n\nExamples\n\njulia> signal = sin.([1:100;]) + 0.03 .* [1:100;]\njulia> detrend(signal)\nVector{Float}\n\n\n\n\n\n","category":"method"},{"location":"#Cardio.getECGBaseline-Tuple{Vector{var\"#s18\"} where var\"#s18\"<:Real, Real}","page":"Home","title":"Cardio.getECGBaseline","text":"getECGBaseline(ecg::Vector{<:Real}, samplerate::Real)\n\nGet the baseline of an ECG signal for baseline correction. Source: Advances in Cardiac Signal Processing - Acharya, U.R. and Suri, J. and Spaan, J.A.E. and Krishnan, S.M. and Technologies, B.      - ISBN: 9783540366751 page: 58f. adaption by Jan F. Kraemer\n\nArgs:\n\n'ecg::Vector{<:Number}': ECG signal\n'samplerate::Number': Sampling rate\n\nExamples\n\njulia> a = getECGBaseline(ecg, samplerate)\nVector{Float64} with ....\n\n\n\n\n\n","category":"method"},{"location":"#Cardio.medfilt1-Tuple{Array{var\"#s15\", N} where {var\"#s15\"<:Real, N}}","page":"Home","title":"Cardio.medfilt1","text":"medfilt1(x::Array{<:Real}; n::Int = 3, padding::String = \"zeropad\", dim::Int = -1)\n\nApply a median filter to a signal vector or array x, similar to Matlabs medfilt1. Using Heap based calculation of the median to increase performance for larger windows n.\n\nArgs:\n\n'x::Array{<:Real}': Array containing real values\n\nKeywords:\n\n'n::Int': Window length. The Median at point i is defined as median(x[i-n+1:i])\n'padding::String': Specifies how to deal with Endpoints. The modes 'zeropad' and 'truncate' are available, with the first as default.\n'dim::Int': Specifies the dimension to be filtered along. As default the first non singleton dimension is chosen.\n\nReturn:\n\n'Array{Float64,N}': Always type Float64 with the same length as the input x\n\nExamples\n\njulia> medfilt1(collect(1:10))\n10-element Array{Float64,1}:\n 1.0\n 2.0\n 3.0\n 4.0\n 5.0\n 6.0\n 7.0\n 8.0\n 9.0\n 9.0\n\n\n\n\n\n","category":"method"},{"location":"#Cardio.sme-Tuple{Vector{var\"#s7\"} where var\"#s7\"<:Real, Vector{var\"#s6\"} where var\"#s6\"<:Real}","page":"Home","title":"Cardio.sme","text":"sme(RR::Vector{<:Real}, SBP::Vector{<:Real}; thresholdRR::Float64 = 4.0, thresholdSBP::Float64 = 1.0, seqLen::Int = 3, delay::Int = 1, minCor::Float64 = 0.8)\n\nCalculate the BaroReflex Sensitivity (BRS) for a serious of RR intervals and respectiv systolic bloodpressure using the Sequence Method (SME).\n\nArgs:\n\n'RR::Vector': Data Vector containing the RR intervals\n'SBP::Vector': Data Vector containing the systolic bloodpressure\n\nKeywords:\n\n'thresholdRR::Float64': Threshold for change in RR interval to qualify for a valid sequence (literature: 4ms)\n'thresholdSBP::Float64': Threshold for change in SBP to qualify for a valid sequence (literature: 1mmHg)\n'seqLen::Int': Minimum length of a valid sequence (literature: 3)\n'delay::Int': Delay between RR and SBP (literature: 1)\n'minCor::Float64': The minimal correlation between RR and SBP in a sequence to qualify as a valid sequence\n'BRS::Float64': The BRS as estimated by the Sequence Method\n\nReturn:\n\nReturns a SME struct for which a plotting recipe is provided, so that found sequences can be inspected by calling plot() when using Plots.jl\n\nExamples\n\njulia> sme(collect(1:10:100), collect(1:10:100))\n1.0\n\n\n\n\n\n","category":"method"},{"location":"#Cardio.theilSenEstimator-Tuple{Any, Any}","page":"Home","title":"Cardio.theilSenEstimator","text":"theilSenEstimator(x, y)\n\nCalculate the Teil Sen Estimator (median of all slopes m = (yⱼ - yᵢ)/(xⱼ - xᵢ )). Stable up to ~27% outliers\n\nArgs:\n\n'x::Vector': Data Vector containing x values\n'y::Vector': Data Vector containing y values\n\nReturn:\n\n'(m, b)::Tuple': m represents slope, b the intersect\n\nExamples\n\njulia> theilSenEstimator(1:10, 1:10)\n(1.0,0.0)\n\n\n\n\n\n","category":"method"}]
}
